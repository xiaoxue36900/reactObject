### 一、关于 jsx 你要知道的：

1.jsx 的出现就是为了让程序员更加方便的创建虚拟 DOM。 2.浏览器是不认识 jsx 的，jsx 方式创建虚拟 DOM 的语法，会被 babel 转换成 js 方式创建的语法。

### 二、jsx 语法规则：

1.不是 js 中的字符串，不允许加单引号。 2.标签里想写 js 表达式，要用{}
3.style 样式要写成：style={{color:'red'}}。
4.class 要改为 className。 5.必须只有一个跟标签。 6.每一个标签必须闭合。
备注：程序员编码时，几乎都会使用 jsx 去定义虚拟 DOM。

### 三、jsx 解析的流程：

1. 遇到 < 开头的代码, 以标签的语法解析，解析规则如下：
   (1) 若<>的标签名首母是小写的，且与 html 标签同名，则直接转化为 html 同名元素，
   如：<span> 、<h1> 、<div>等。
   (2) 若<>的标签名的首字母是大写的，则寻找同名组件，随后解析组件。
   (3) 若<>的标签名不符合上述规则，则报错。
2. 遇到以 { 开头的代码，以 JS 语法解析，立刻执行{}中的 JS 表达式。

### 四、工厂函数定义组件

代码的执行过过程： 1.由于写了 ReactDOM.render(<Demo/>..... 会触发 React 去查找 Demo 组件定义的位置。 2.找到 Demo 组件后发现，该组件是用工厂函数定义的，React 立刻调用 Demo，获取到返回值。 3.将返回值(虚拟 DOM)渲染到页面指定位置。

### 五、ES6 类定义组件

代码的执行过过程： 1.由于写了 ReactDOM.render(<Demo/>..... 会触发 React 去查找 Demo 组件定义的位置。 2.找到 Demo 组件后发现，该组件是用类定义的，React 立刻 new 一个 Demo 的实例出来。 3.通过上一步的实例去调用了 render 方法，获取了方法的返回值。 4.将返回值(虚拟 DOM)渲染到页面指定位置。
如何判断一个组件是否复杂？
如果该组件有状态，那么就是复杂组件。反之就不是。

ES6 类组件 实例对象三大属性 state 状态
作用：用来更新用户界面
使用：

1. 初始化状态
   constructor() {
   super();
   this.state = { xxx }
   }
   --> 简写
   state = {
   xxx
   }

2. 读取状态
   this.state.xxx
3. 更新状态
   this.setState({ xxx })

### 六、定义组件有哪些注意事项

1.  组件名首字母必须大写
    原因是：
    JSX 一旦标签 <myComponent1 /> 首字母小写就会当做 html 元素解析，
    但是 html 中没有 myComponent1 这个元素就会报错
    所以首字母大写 <MyComponent1 />，就会当做组件解析
    内部会判断是工厂函数还是 ES6 类组件
2.  内部返回虚拟 DOM 对象元素必须有结束符
    单标签自结束标签
    双标签
3.  内部返回多个虚拟 DOM 对象，必须有且有一个根标签

### 七、工厂函数组件和 ES6 类组件的区别

1.  this 不一样
    工厂函数没有 this
    ES6 类组件函数中有 this
2.  功能不一样
    因为工厂函数没有 this，有些功能默认实现不了
    因为 ES6 类组件有 this，所以可以实现

### 总结：

工厂函数组件一般用来定义功能简单组件
ES6 类组件一般用来定义功能复杂组件

在 React 类组件中，this 指向：

1. 如果是生命周期函数中，this 指向组件实例对象 constructor / render
2. 如果在其他自定义函数中，this 默认指向 undefined（严格模式）
   需求: 需要将 其他自定义函数 this 指向组件实例对象
   解决：箭头函数

class 定义类
extends 继承
constructor 类的构造方法
super() 调用父类的构造方法 / super.xxx() 调用父类的 xxx 方法
static 定义类的静态方法
（类的直接方法，只有类可以使用，实例对象不能使用）
普通方法是实例对象可以使用，类不能使用
